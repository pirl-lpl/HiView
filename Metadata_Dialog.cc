/*	Metadata_Dialog

HiROC CVS ID: $Id: Metadata_Dialog.cc,v 1.18 2012/09/16 07:41:32 castalia Exp $

Copyright (C) 2012  Arizona Board of Regents on behalf of the
Planetary Image Research Laboratory, Lunar and Planetary Laboratory at
the University of Arizona.

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License, version 2.1,
as published by the Free Software Foundation.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.

*******************************************************************************/

#include	"Metadata_Dialog.hh"

#include	"Parameter_Tree_View.hh"
#include	"PDS_Metadata.hh"

#include	"PVL.hh"
using idaeim::PVL::Parameter;
using idaeim::PVL::Aggregate;
using idaeim::PVL::Parser;
using idaeim::PVL::Lister;

#include	"HiView_Config.hh"
#include	"Drawn_Line.hh"

#include	<QWidget>
#include	<QSplitter>
#include	<QTextEdit>
#include	<QGridLayout>
#include	<QMargins>
#include	<QVBoxLayout>
#include	<QLabel>
#include	<QAction>
#include	<QModelIndex>
#include	<QEvent>
#include	<QMenuBar>
#include	<QMenu>
#include	<QFileDialog>
#include	<QFileInfo>
#include	<QErrorMessage>
#include	<QList>

#include	<fstream>
using 		std::ofstream;
using		std::string;


#if defined (DEBUG_SECTION)
/*	DEBUG_SECTION controls

	DEBUG_SECTION report selection options.
	Define any of the following options to obtain the desired debug reports:

	Note: In the context of Makefiles generated by the Qt qmake utility
	the DEBUG_SECTION token is always defined when a "debug" build is
	done. The token will be defined as empty by default in the Makefile
	unless DEBUG_SECTION is defined by the user as an environment
	variable or on the make command line. Since an empty definition can
	not be distinguished from a 0 definition the default when a debug
	build is done is to use DEBUG_OFF.
*/
#define	DEBUG_OFF				0
#define	DEBUG_ALL				(-1)
#define	DEBUG_CONSTRUCTORS		(1 << 0)
#define DEBUG_SELECTION			(1 << 1)
#define DEBUG_SAVE				(1 << 2)

#if (DEBUG_SECTION+0) == 0
#undef	DEBUG_SECTION
#define	DEBUG_SECTION DEBUG_OFF

#else
#include	"Parameter_Tree_Model.hh"	//	For QModelIndex output operator.
using idaeim::PVL::Parameter;

#include	"HiView_Utilities.hh"		//	For QString output operator.

#include <iostream>
#include <iomanip>
using std::clog;
using std::endl;
using std::boolalpha;
using std::dec;
using std::hex;
#endif

#endif	//	DEBUG_SECTION


namespace UA
{
namespace HiRISE
{
/*==============================================================================
	Constants
*/
const char* const
	Metadata_Dialog::ID =
		"UA::HiRISE::Metadata_Dialog ($Revision: 1.18 $ $Date: 2012/09/16 07:41:32 $)";

#ifndef METADATA_DIALOG_DEFAULT_WIDTH
#define METADATA_DIALOG_DEFAULT_WIDTH	500
#endif
#ifndef METADATA_DIALOG_DEFAULT_HEIGHT
#define METADATA_DIALOG_DEFAULT_HEIGHT	309
#endif
const int
	Metadata_Dialog::DEFAULT_WIDTH	= METADATA_DIALOG_DEFAULT_WIDTH,
	Metadata_Dialog::DEFAULT_HEIGHT	= METADATA_DIALOG_DEFAULT_HEIGHT;

/*==============================================================================
	Application configuration parameters
*/
#define Panel_Frame_Style \
	HiView_Config::Panel_Frame_Style
#define Panel_Frame_Width \
	HiView_Config::Panel_Frame_Width
#define Heading_Line_Weight \
	HiView_Config::Heading_Line_Weight

/*==============================================================================
	Static data
*/
QErrorMessage
	*Metadata_Dialog::Error_Message	= NULL;

/*==============================================================================
	Constructors
*/
Metadata_Dialog::Metadata_Dialog
	(
	Aggregate*		parameters,
	QWidget*		parent,
	Qt::WindowFlags	flags
	)
	:	QDialog (parent, flags),
		Tree_View (new Parameter_Tree_View (parameters)),
		Comments (new QTextEdit),
		Save_Dialog (NULL)
{initialize ();}


Metadata_Dialog::Metadata_Dialog
	(
	QWidget*		parent,
	Qt::WindowFlags	flags
	)
	:	QDialog (parent, flags),
		Tree_View (new Parameter_Tree_View),
		Comments (new QTextEdit),
		Save_Dialog (NULL)
{initialize ();}


void
Metadata_Dialog::initialize ()
{
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << ">>> Metadata_Dialog" << endl;
#endif
#if defined (DEBUG_SECTION) && DEBUG_SECTION != 0
clog << boolalpha;
#endif
//	Set the default title and the modality (non-modal).
setWindowTitle (tr ("Metadata"));
//	Allow non-modal (show instead of exec) operation.
setModal (false);
//	Enable keyboard focus.
setFocusPolicy (Qt::StrongFocus);

//	Dialog layout.
QVBoxLayout*
	layout = new QVBoxLayout (this);

//	Menus.
layout->addWidget (create_menus ());

layout->addWidget (new Drawn_Line (Heading_Line_Weight));

//	Tree_View:

//	The columns should start out with equal widths.
Tree_View->setColumnWidth (0, DEFAULT_WIDTH >> 1);
//	Frame styling.
Tree_View->setFrameStyle (Panel_Frame_Style);
Tree_View->setLineWidth (Panel_Frame_Width);
Tree_View->setMinimumSize (50, 50);

//	Comments:
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "    Comments panel layout" << endl;
#endif
QWidget*
	comments = new QWidget;
QGridLayout*
	grid = new QGridLayout (comments);

/*	The Drawn_Line ignores content margins.
	Artificial margins, in the form of empty grid columns, are used instead.
*/
grid->setContentsMargins (0, 0, 0, 0);
QMargins
	margins (Tree_View->contentsMargins ());
grid->setHorizontalSpacing (0);
grid->setColumnMinimumWidth (0, margins.left ());
grid->setColumnStretch (0, 0);
grid->setColumnStretch (1, 10);
grid->setColumnMinimumWidth (2, margins.right ());
grid->setColumnStretch (2, 0);

grid->addWidget (new Drawn_Line (Heading_Line_Weight),
	0, 1, Qt::AlignBottom);
grid->addWidget (new QLabel (tr ("<b>Comments</b>")),
	1, 1, Qt::AlignLeft | Qt::AlignVCenter);

Comments->setReadOnly (true);
//	Frame styling.
Comments->setFrameStyle (Panel_Frame_Style);
Comments->setLineWidth (Panel_Frame_Width);
grid->addWidget (Comments,
	2, 0, 1, -1);

//	Vertical QSplitter.
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "    QSplitter initialization" << endl;
#endif
QSplitter*
	splitter = new QSplitter (Qt::Vertical, this);
splitter->addWidget (Tree_View);
splitter->setCollapsible (0, false);
splitter->addWidget (comments);

//	Give the Comments the minimum space; the Tree_View gets the rest.
splitter->setStretchFactor (0, 1);
splitter->setStretchFactor (1, 0);
QList<int>
	splitter_sizes = splitter->sizes ();
int
	adjustment =
		splitter_sizes[1] - comments->minimumSizeHint ().height ();
splitter_sizes[0] += adjustment;
splitter_sizes[1] -= adjustment;
splitter->setSizes (splitter_sizes);

layout->addWidget (splitter);

//	Watch for tree item selections.
connect (Tree_View->selectionModel (),
	SIGNAL (selectionChanged (const QItemSelection&, const QItemSelection&)),
	SLOT (selection_changed (const QItemSelection&, const QItemSelection&)));

//	Close action.
QAction*
	action = new QAction (tr ("Close Window"), this);
action->setShortcut (tr ("Ctrl+W"));
connect (action,
	SIGNAL (triggered ()),
	SLOT (close ()));
addAction (action);
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "<<< Metadata_Dialog" << endl;
#endif
}

/*==============================================================================
	Menus
*/
QMenuBar* 
Metadata_Dialog::create_menus ()
{
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << ">>> Metadata_Dialog::create_menus" << endl;
#endif
QMenuBar*
	menu_bar (new QMenuBar (this));
menu_bar->setNativeMenuBar (false);

QMenu*
	menu;
QAction*
	action;
menu = menu_bar->addMenu (tr ("&File"));
action = new QAction (tr ("&Save..."), this);
action->setShortcut (tr ("Ctrl+S"));
connect	(action,
	SIGNAL (triggered ()),
	SLOT (save_metadata ()));
menu->addAction (action);

Save_Selected_Action = new QAction (tr ("S&ave Selected..."), this);
Save_Selected_Action->setShortcut (tr ("Alt+S"));
Save_Selected_Action->setEnabled (false);
connect (Save_Selected_Action,
	SIGNAL (triggered ()),
	SLOT (save_selected_metadata ()));
menu->addAction (Save_Selected_Action);

#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "<<< Metadata_Dialog::create_menus" << endl;
#endif
return menu_bar;
}

/*==============================================================================
	Accessors
*/
void
Metadata_Dialog::parameters
	(
	Aggregate*	params
	)
{
Tree_View->parameters (params);
//	Reconnect to the selectionChanged signal if the selectionModel changed.
connect (Tree_View->selectionModel (),
	SIGNAL (selectionChanged (const QItemSelection&, const QItemSelection&)),
	SLOT (selection_changed (const QItemSelection&, const QItemSelection&)),
	Qt::UniqueConnection);
}


idaeim::PVL::Aggregate*
Metadata_Dialog::parameters () const
{return Tree_View->parameters ();}


bool
Metadata_Dialog::root_visible () const
{return Tree_View->root_visible ();}


void
Metadata_Dialog::root_visible
	(
	bool	enable
	)
{Tree_View->root_visible (enable);}


QString
Metadata_Dialog::root_name () const
{return Tree_View->root_name ();}


void
Metadata_Dialog::root_name
	(
	const QString& new_name
	)
{Tree_View->root_name (new_name);}


QString
Metadata_Dialog::default_root_name ()
{return Parameter_Tree_View::default_root_name ();}

QSize
Metadata_Dialog::sizeHint () const
{return QSize (DEFAULT_WIDTH, DEFAULT_HEIGHT);}


bool
Metadata_Dialog::alternating_row_colors () const
{return Tree_View->alternatingRowColors ();}


void
Metadata_Dialog::alternating_row_colors
	(
	bool	enable
	)
{return Tree_View->setAlternatingRowColors (enable);}

/*==============================================================================
	Slots
*/
void
Metadata_Dialog::selection_changed
	(
	const QItemSelection&	selected,
	const QItemSelection&	/*deselected*/
	)
{
#if (DEBUG_SECTION & DEBUG_SELECTION)
clog << ">>> Metadata_Dialog::selection_changed" << endl;
#endif
const QModelIndexList
	list (selected.indexes ());
if (list.isEmpty ())
	{
	Save_Selected_Action->setEnabled (false);
	Comments->clear ();
	#if (DEBUG_SECTION & DEBUG_SELECTION)
	clog << "    no selection" << endl;
	#endif
	}
else
	{
	Save_Selected_Action->setEnabled (true);
	Comments->setPlainText (Tree_View->comments (list[0]));
	#if (DEBUG_SECTION & DEBUG_SELECTION)
	clog << "    comments from " << list[0] << endl
		 << "    parameter "
		 	<< static_cast<Parameter*>(list[0].internalPointer ())->name () << endl
		 << Tree_View->comments (list[0]) << endl;
	#endif
	}
#if (DEBUG_SECTION & DEBUG_SELECTION)
clog << "<<< Metadata_Dialog::selection_changed" << endl;
#endif
}


bool
Metadata_Dialog::save_selected_metadata ()
{
bool
	saved (false);
Parameter_Tree_View::Parameter_List
	selected_parameters (Tree_View->selected_parameters ());
if (selected_parameters.isEmpty ())
	Save_Selected_Action->setEnabled (false);
else
	{
	QString
		title;
	if (selected_parameters[0])
		title
			.append (tr ("Save "))
			.append (selected_parameters[0]->name ().c_str ())
			.append (tr (" Metadata"));
	saved = save_metadata (selected_parameters[0], title);
	}
return saved;
}


bool
Metadata_Dialog::save_metadata
	(
	idaeim::PVL::Parameter*	metadata,
	const QString&			title
	)
{
#if (DEBUG_SECTION & DEBUG_SAVE)
clog << ">>> Metadata_Dialog::save: @ " << (void*)metadata << endl;
#endif
bool
	saved (false);
if (! metadata)
	metadata = Tree_View->parameters ();
if (metadata)
	{
	if (! Save_Dialog)
		{ 
		Save_Dialog = new QFileDialog (this);
		Save_Dialog->setAcceptMode (QFileDialog::AcceptSave);
		Save_Dialog->setFileMode (QFileDialog::AnyFile);
		Save_Dialog->setOptions
			(QFileDialog::DontUseNativeDialog |
			 QFileDialog::DontResolveSymlinks);
		Save_Dialog->setConfirmOverwrite (true);
		}
	if (! title.isEmpty ())
		Save_Dialog->setWindowTitle (title);
	else
		Save_Dialog->setWindowTitle (tr ("Save Metadata"));

	if (Save_Dialog->exec())
		{
		QString
			pathname (Save_Dialog->selectedFiles().value (0).trimmed ());
		if (! pathname.isEmpty ())
			{
			#if (DEBUG_SECTION & DEBUG_SAVE)
			clog << "    metadata name = "
					<< metadata->name () << endl
				 << "    metadata parent @ "
				 	<< (void*)metadata->parent () << endl;
			if (metadata->parent ())
				clog << "    metadata parent name = "
						<< metadata->parent ()->name () << endl;
			#endif
			//	Check for special container Aggregates.
			bool
				tmp_name (true);
			string
				name (metadata->name ());
			if (name.empty () ||
				name == PDS_Metadata::PDS_METADATA_GROUP ||
				name == default_root_name ().toStdString ())
				//	Use the container name to suppress container listing.
				metadata->name (Parser::CONTAINER_NAME);
			else
				tmp_name = false;

			saved = save (metadata, pathname);

			if (tmp_name)
				//	Restore the name.
				metadata->name (name);
			}
		}
	}
#if (DEBUG_SECTION & DEBUG_SAVE)
clog << "<<< Metadata_Dialog::save: " << saved << endl;
#endif
return saved;
}

/*==============================================================================
	Utilities
*/
bool
Metadata_Dialog::save
	(
	const Parameter* const	metadata,
	const QString&			pathname
	)
{
#if (DEBUG_SECTION & DEBUG_SAVE)
clog << ">>> Metadata_Dialog::save: " << pathname << endl;
#endif
bool 
	saved (false);
if (metadata &&
	! pathname.isEmpty ())
	{
	QString
		message;
	QFileInfo*
		file_info (new QFileInfo (pathname));
	if (! file_info->exists () ||
		(file_info->isFile () &&
		 file_info->isWritable ()))
		{
		ofstream 
			file (pathname.toStdString ().c_str ());
		if (file)
			{
			try
				{
				file << *PDS_Metadata::metadata_lister () << *metadata;
				saved = true;
				}
			catch (...)
				{
				//	No exceptions thrown.
				message = "Failed to write the file.";
				}
			}
		else
			message = "Could not open the file for writing.";
		}
	else
		message = "Existing file can not be overwritten.";
	if (! message.isEmpty ())
		{
		message
			.prepend ('\n')
			.prepend (pathname)
			.prepend ("Unable to save the metadata to file\n");
		if (! Error_Message)
			Error_Message = new QErrorMessage;
		Error_Message->showMessage (message.replace ("\n", "<br>"));
		}
	}
#if (DEBUG_SECTION & DEBUG_SAVE)
else
	{
	if (! metadata)
		clog << "    No metadata" << endl;
	if (pathname.isEmpty ())
		clog << "    No pathname" << endl;
	}
clog << "<<< Metadata_Dialog::save: " << saved << endl;
#endif
return saved;
}

/*==============================================================================
	Event Handler
*/
bool
Metadata_Dialog::event
	(
	QEvent*	event
	)
{
bool
	visible = false;
switch (event->type ())
	{
	case QEvent::Show:
		visible = true;
    case QEvent::Hide:
		//	>>> SIGNAL <<<
		emit visibility_changed (visible);
	default:
		break;
	}
return QDialog::event (event);
}


}	//	namespace HiRISE
}	//	namespace UA
