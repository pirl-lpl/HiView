/*	Value_Tree_Model

HiROC CVS ID: $Id: Value_Tree_Model.cc,v 1.11 2012/05/10 05:23:04 castalia Exp $

Copyright (C) 2012  Arizona Board of Regents on behalf of the
Planetary Image Research Laboratory, Lunar and Planetary Laboratory at
the University of Arizona.

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License, version 2.1,
as published by the Free Software Foundation.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.

*******************************************************************************/

#include	"Value_Tree_Model.hh"

#include	"PVL.hh"
using idaeim::PVL::Array;
using idaeim::PVL::Value;

#include	<string>
using std::string;


#if defined (DEBUG_SECTION)
/*	DEBUG_SECTION controls

	DEBUG_SECTION report selection options.
	Define any of the following options to obtain the desired debug reports:

	Note: In the context of Makefiles generated by the Qt qmake utility
	the DEBUG_SECTION token is always defined when a "debug" build is
	done. The token will be defined as empty by default in the Makefile
	unless DEBUG_SECTION is defined by the user as an environment
	variable or on the make command line. Since an empty definition can
	not be distinguished from a 0 definition the default when a debug
	build is done is to use DEBUG_OFF.
*/
#define	DEBUG_OFF				0
#define	DEBUG_ALL				(-1)
#define	DEBUG_CONSTRUCTORS		(1 << 0)
#define DEBUG_MODEL				(1 << 1)
#define DEBUG_DATA				(1 << 2)

#if (DEBUG_SECTION + 0) == 0
#undef	DEBUG_SECTION
#define	DEBUG_SECTION DEBUG_OFF
#else
#include "Parameter_Tree_Model.hh"	//	For QModelIndex output operator.
#endif

#include <iostream>
#include <iomanip>
using std::clog;
using std::endl;
using std::boolalpha;

#endif	//	DEBUG_SECTION


namespace UA
{
namespace HiRISE
{
/*==============================================================================
	Constants
*/
const char* const
	Value_Tree_Model::ID =
		"UA::HiRISE::Value_Tree_Model ($Revision: 1.11 $ $Date: 2012/05/10 05:23:04 $)";

/*==============================================================================
	Constructors
*/
Value_Tree_Model::Value_Tree_Model
	(
	Array*		root,
	QObject*	parent
	)
	:	QAbstractItemModel (parent),
		Root (root)
{
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "<-> Value_Tree_Model::Value_Tree_Model: root @ "
		<< (void*)root << endl;
#endif
#if (DEBUG_SECTION != 0)
clog << boolalpha;
QHash<int, QByteArray>
	role_names;
role_names.insert (0, "Display");
role_names.insert (1, "Decoration");
role_names.insert (2, "Edit");
role_names.insert (3, "ToolTip");
role_names.insert (4, "StatusTip");
role_names.insert (5, "WhatsThis");
role_names.insert (6, "Font");
role_names.insert (7, "TextAlignment");
role_names.insert (8, "Background");
role_names.insert (9, "Foreground");
role_names.insert (10, "CheckState");
role_names.insert (11, "AccessibleText");
role_names.insert (12, "AccesibleDescription");
role_names.insert (13, "SizeHint");
setRoleNames (role_names);
#endif
}


Value_Tree_Model::Value_Tree_Model
	(
	const Value_Tree_Model&	model
	)
	:	QAbstractItemModel (),
		Root (model.Root)
{
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "<-> Value_Tree_Model::Value_Tree_Model: copy @ "
		<< (void*)(&model) << " with root @ " << (void*)Root << endl;
#endif
#if (DEBUG_SECTION != 0)
clog << boolalpha;
QHash<int, QByteArray>
	role_names;
role_names.insert (0, "Display");
role_names.insert (1, "Decoration");
role_names.insert (2, "Edit");
role_names.insert (3, "ToolTip");
role_names.insert (4, "StatusTip");
role_names.insert (5, "WhatsThis");
role_names.insert (6, "Font");
role_names.insert (7, "TextAlignment");
role_names.insert (8, "Background");
role_names.insert (9, "Foreground");
role_names.insert (10, "CheckState");
role_names.insert (11, "AccessibleText");
role_names.insert (12, "AccesibleDescription");
role_names.insert (13, "SizeHint");
setRoleNames (role_names);
#endif
}


Value_Tree_Model&
Value_Tree_Model::operator= (const Value_Tree_Model& model)
{
if (this != &model)
	Root = model.Root;
return *this;
}

/*==============================================================================
	QAbstractItemModel interface implementation
*/
QModelIndex
Value_Tree_Model::index
	(
	int					row,
	int					column,
	const QModelIndex&	parent_index
	) const
{
#if (DEBUG_SECTION & DEBUG_MODEL)
clog << ">>> Value_Tree_Model::index: "
		<< "row " << row << " col " << column << endl
	 << "    parent " << parent_index  << endl
	 << "      is valid = " << parent_index.isValid () << endl;
#endif
QModelIndex
	index;
if (column == 0)
	{
	Array*
		parent = NULL;
	if (parent_index.isValid ())
		{
		//	Non-root parent.
		parent = static_cast<Array*>(parent_index.internalPointer ());
		if (parent &&
			row < (int)parent->size ())
			index = createIndex (row, column, &(*parent)[row]);
		}
	else
	if (row == 0)
		//	Root parent.
		index = createIndex (row, column, Root);
	}
#if (DEBUG_SECTION & DEBUG_MODEL)
clog << "<<< Value_Tree_Model::index: " << index << endl;
#endif
return index;
}


QVariant
Value_Tree_Model::data
	(
	const QModelIndex&	index,
	int					role
	) const
{
#if (DEBUG_SECTION & DEBUG_DATA)
clog << ">>> Value_Tree_Model::data:" << endl
	 << "    " << index << endl
	 << "    role = " << role
	 	<< " (" << qPrintable (QString (roleNames ().value (role)))
		<< ')' << endl;
#endif
QVariant
	datum;
if (role == Qt::DisplayRole &&
	index.isValid ())
	{
	Value*
		value = static_cast<Value*>(index.internalPointer ());
	if (value->is_Array ())
		datum = tr (value->type_name ().c_str ());
	else
		datum = QString::fromStdString (static_cast<string>(*value));
	}
#if (DEBUG_SECTION & DEBUG_DATA)
clog << "<<< Value_Tree_Model::data: "
		<< qPrintable (datum.toString ()) << endl;
#endif
return datum;
}


QModelIndex
Value_Tree_Model::parent
	(
	const QModelIndex& index
	) const
{
#if (DEBUG_SECTION & DEBUG_MODEL)
clog << ">>> Value_Tree_Model::parent: " << index << endl
	 << "      is valid = " << index.isValid () << endl;
#endif
QModelIndex
	parent_index;
if (index.isValid ())
	{
	Value*
		value = static_cast<Value*>(index.internalPointer ());
	if (value)
		{
		value = value->parent ();
		parent_index = createIndex (value_row (value), 0, value);
		}
	}
#if (DEBUG_SECTION & DEBUG_MODEL)
clog << "<<< Value_Tree_Model::parent: " << parent_index << endl;
#endif
return parent_index;
}


int
Value_Tree_Model::rowCount
	(
	const QModelIndex& parent
	) const
{
if (!parent.isValid ())
	return 1;

Value*
	referenced_value = static_cast<Value*> (parent.internalPointer ());

if (!referenced_value->is_Array ())
	return 0;

return static_cast<Array*> (referenced_value)->size ();
}
/*==============================================================================
	Accessors
*/
QString
Value_Tree_Model::units
	(
	const QModelIndex&	index
	) const
{
QString
	units;
Value*
	value = static_cast<Value*>(index.internalPointer ());
if (value)
	units = value->units ().c_str ();
return units;
}

/*==============================================================================
	Helpers
*/
int
Value_Tree_Model::value_row
	(
	Value*	value
	) const
{
int
	row = -1;	//	Not found.
if (value)
	{
	Array*
		parent = value->parent ();
	if (parent)
		{
		row = parent->size ();
		while (row--)
			if (&(*parent)[row] == value)
				break;
		}
	else
		row = 0;
	}
return row;
}


}	// end namespace HiRISE
}	// end namespace UA


