/*	Parameter_Tree_View

HiROC CVS ID: $Id: Parameter_Tree_View.cc,v 1.8 2012/08/31 06:54:34 castalia Exp $

Copyright (C) 2012  Arizona Board of Regents on behalf of the
Planetary Image Research Laboratory, Lunar and Planetary Laboratory at
the University of Arizona.

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License, version 2.1,
as published by the Free Software Foundation.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.

*******************************************************************************/

#include	"Parameter_Tree_View.hh"

#include	"Parameter_Tree_Model.hh"
#include	"Value_Tree_Model.hh"

#include	"PVL.hh"
using idaeim::PVL::Parameter;
using idaeim::PVL::Aggregate;
using idaeim::PVL::Array;

#include	<QTreeView>
#include	<QList>

#include	<string>
using std::string;
#include	<sstream>
using std::ostringstream;
#include	<iomanip>
using std::endl;
#include	<stdexcept>
using std::invalid_argument;


#if defined (DEBUG_SECTION)
/*	DEBUG_SECTION controls

	DEBUG_SECTION report selection options.
	Define any of the following options to obtain the desired debug reports:.

	Note: In the context of Makefiles generated by the Qt qmake utility
	the DEBUG_SECTION token is always defined when a "debug" build is
	done. The token will be defined as empty by default in the Makefile
	unless DEBUG_SECTION is defined by the user as an environment
	variable or on the make command line. Since an empty definition can
	not be distinguished from a 0 definition the default when a debug
	build is done is to use DEBUG_OFF.
*/
#define	DEBUG_OFF				0
#define	DEBUG_ALL				(-1)
#define	DEBUG_CONSTRUCTORS		(1 << 0)
#define DEBUG_PARAMETERS		(1 << 2)
#define DEBUG_ARRAY_SUBTREES	(1 << 3)

#if (DEBUG_SECTION + 0) == 0
#undef	DEBUG_SECTION
#define	DEBUG_SECTION DEBUG_OFF
#endif

#include <iostream>
#include <iomanip>
using std::clog;
using std::boolalpha;

#endif	//	DEBUG_SECTION


namespace UA
{
namespace HiRISE
{
/*==============================================================================
	Constants
*/
const char* const
	Parameter_Tree_View::ID = "UA::HiRISE::Parameter_Tree_View ($Revision: 1.8 $ $Date: 2012/08/31 06:54:34 $)";


#ifndef PARAMETER_VIEW_DEFAULT_ANIMATION
#define PARAMETER_VIEW_DEFAULT_ANIMATION	true
#endif
const bool
	Parameter_Tree_View::DEFAULT_ANIMATION	= PARAMETER_VIEW_DEFAULT_ANIMATION;

/*==============================================================================
	Constructors
*/
Parameter_Tree_View::Parameter_Tree_View
	(
	Aggregate*	parameters,
	QWidget*	parent
	)
	:	QTreeView (parent),
		Tree_Model (NULL),
		Tree_Model_Locally_Owned (false)
{
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << ">>> Parameter_Tree_View" << endl;
if (parameters)
	clog << "    parameters -" << endl
		 << *parameters << endl;
else
	clog << "    no parameters" << endl;
#endif
this->parameters (parameters);
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "<<< Parameter_Tree_View" << endl;
#endif
}


Parameter_Tree_View::Parameter_Tree_View
	(
	Parameter_Tree_Model*	model,
	QWidget*				parent
	)
	:	QTreeView (parent),
		Tree_Model (model),
		Tree_Model_Locally_Owned (false)
{
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << ">>> Parameter_Tree_View" << endl
	 << "    model parameters -" << endl
	 << *(model->parameters ()) << endl;
#endif
QTreeView::setModel (model);
initialize ();
#if (DEBUG_SECTION & DEBUG_CONSTRUCTORS)
clog << "<<< Parameter_Tree_View" << endl;
#endif
}


Parameter_Tree_View::~Parameter_Tree_View ()
{
if (Tree_Model_Locally_Owned &&
	Tree_Model)
	delete Tree_Model;
}


void
Parameter_Tree_View::initialize ()
{
QTreeView::setAnimated (DEFAULT_ANIMATION);
setUniformRowHeights (! subtrees ());	//	Optimization.
setSortingEnabled (false);
}

/*==============================================================================
	Accessors
*/
void
Parameter_Tree_View::parameters
	(
	Aggregate*	params
	)
{
#if (DEBUG_SECTION & DEBUG_PARAMETERS)
clog << ">>> Parameter_Tree_View::parameters" << endl;
if (params)
	clog << "    params -" << endl
		 << *params;
else
	clog << "    no params" << endl;
clog << "    constructing new Parameter_Tree_Model ..." << endl;
#endif
Tree_Model_Locally_Owned = true;
Tree_Model = new Parameter_Tree_Model (params);

QItemSelectionModel
	*selection_model = selectionModel ();

#if (DEBUG_SECTION & DEBUG_PARAMETERS)
clog << "    QItemSelectionModel @ " << (void*)selection_model << endl
	 << "    QTreeView::setModel @ " << (void*)Tree_Model << endl;
#endif
QTreeView::setModel (Tree_Model);
#if (DEBUG_SECTION & DEBUG_PARAMETERS)
clog << "    delete QItemSelectionModel" << endl;
#endif
delete selection_model;

initialize ();
#if (DEBUG_SECTION & DEBUG_PARAMETERS)
clog << "<<< Parameter_Tree_View::parameters" << endl;
#endif
}


Aggregate*
Parameter_Tree_View::parameters () const
{return static_cast<Parameter_Tree_Model*>(model ())->parameters ();}


void
Parameter_Tree_View::setModel
	(
	QAbstractItemModel* model
	)
{
Parameter_Tree_Model*
	parameter_model = dynamic_cast<Parameter_Tree_Model*>(model);
if (parameter_model)
	{
	Tree_Model_Locally_Owned = false;
	QTreeView::setModel (parameter_model);
	initialize ();
	}
else
	{
	ostringstream
		message;
	message
		<< ID << endl
		<< "Invalid data model for a Parameter_Tree_View;" << endl
		<< "a Parameter_Tree_Model is required.";
	throw invalid_argument (message.str ());
	}
}


bool
Parameter_Tree_View::root_visible () const
{return static_cast<Parameter_Tree_Model*>(model ())->root_visible ();}


void
Parameter_Tree_View::root_visible
	(
	bool	enable
	)
{static_cast<Parameter_Tree_Model*>(model ())->root_visible (enable);}


QString
Parameter_Tree_View::root_name () const
{return static_cast<Parameter_Tree_Model*>(model ())->root_name ();}


void
Parameter_Tree_View::root_name
	(
	const QString& name
	)
{static_cast<Parameter_Tree_Model*>(model ())->root_name (name);}


QString
Parameter_Tree_View::default_root_name ()
{return Parameter_Tree_Model::default_root_name ();}


QString
Parameter_Tree_View::comments
	(
	const QModelIndex&	index
	) const
{return static_cast<Parameter_Tree_Model*>(model ())->comments (index);}


Parameter_Tree_View::Parameter_List
Parameter_Tree_View::selected_parameters () const
{
Parameter_List
	parameter_list;
QModelIndexList
	model_list (selectionModel ()->selectedRows ());
for (int
		index = 0;
		index < model_list.size ();
	  ++index)
	parameter_list
		<< static_cast <Parameter*>(model_list[index].internalPointer ());
return parameter_list;
}


void
Parameter_Tree_View::setAnimated
	(
	bool	enable
	)
{
if (enable != isAnimated ())
	{
	QTreeView::setAnimated (enable);

	Parameter_Tree_Model*
		parameter_model = static_cast<Parameter_Tree_Model*>(model ());
	QTreeView*
		subtree;
	QModelIndex
		index,
		parent;
	int
		row = 0,
		row_count = 1;

	//	Walk through the tree heirarchy looking for subtrees.
	while (true)
		{
		if (row >= row_count)
			{
			if (parent.isValid ())
				{
				//	Ascend to the row following the parent.
				row = parent.row () + 1;
				row_count = parameter_model->rowCount (parent);
				parent = parameter_model->parent (parent);	//	Grandparent.
				continue;
				}
			else
				//	Returned to the root.
				break;
			}

		index = parameter_model->index (row, 0, parent);
		if (parameter_model->hasChildren (index))
			{
			//	Descend into the node that has children.
			row = 0;
			row_count = parameter_model->rowCount (index);
			parent = index;	//	Where to come back to after scanning children.
			continue;
			}

		index = parameter_model->index (row, 1, parent);
		subtree = dynamic_cast<QTreeView*>(indexWidget (index));
		if (subtree)
			subtree->setAnimated (enable);
		++row;
		}
	}
}

/*==============================================================================
	Helpers
*/
bool
Parameter_Tree_View::subtrees ()
{
#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
clog << ">>> Parameter_Tree_View::subtrees" << endl;
string
	name ("ROOT");
#endif
Parameter_Tree_Model*
	parameter_model = static_cast<Parameter_Tree_Model*>(model ());
QTreeView*
	subtree = NULL;
Value_Tree_Model*
	array_model;
QModelIndex
	index,
	parent;
Parameter*
	parameter;
int
	row = 0,
	row_count = 1,
	//	Height of Array subtree.
	subtree_height = (fontMetrics ().height () + 1) * 5;

//	Walk through the tree heirarchy looking for Parameters with Arrays.
while (true)
	{
	#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
	clog << "--> row " << row << '/' << row_count << " in " << name << endl;
	#endif
	if (row >= row_count)
		{
		#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
		clog << "    parent " << parent << endl;
		#endif
		if (parent.isValid ())
			{
			//	Ascend to the row following the parent.
			row = parent.row () + 1;
			parent = parameter_model->parent (parent);	//	Grandparent.
			row_count = parameter_model->rowCount (parent);
			#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
			clog << "    ascend to grandparent " << parent << endl;
			parameter = static_cast<Parameter*>(parent.internalPointer ());
			if (parameter)
				name = parameter->name ();
			else
				name = "ROOT";
			clog << "      " << name << endl;
			#endif
			continue;
			}
		else
			{
			//	Returned to the root.
			#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
			clog << "    invalid parent; returned to the root" << endl;
			#endif
			break;
			}
		}

	index = parameter_model->index (row, 0, parent);
	#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
	clog << "    " << index << endl;
	parameter = static_cast<Parameter*>(index.internalPointer ());
	if (parameter)
		clog << "      parameter " << parameter->name () << endl;
	else
		clog << "      no parameter!";
	#endif
	if (parameter_model->hasChildren (index))
		{
		//	Descend into the node that has children.
		row = 0;
		row_count = parameter_model->rowCount (index);
		parent = index;	//	Where to come back to after scanning children.
		#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
		clog << "    descend into subgroup" << endl;
		name = parameter->name ();
		#endif
		continue;
		}

	parameter = static_cast<Parameter*>(index.internalPointer ());
	if (parameter &&
		parameter->is_Assignment () &&
		parameter->value ().is_Array ())
		{
		#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
		clog << "      Array" << endl;
		#endif
		subtree = new QTreeView (this);	//	subtree parent is this view.
		subtree->setHeaderHidden (true);
		subtree->setMaximumHeight (subtree_height);
		subtree->setUniformRowHeights (true);	//	Optimization.
		subtree->setAnimated (isAnimated ());
		subtree->setSortingEnabled (false);

		array_model = new Value_Tree_Model
			(static_cast<Array*>(&parameter->value ()));
		//	Ownership of the array_model is passed to the subtree.
		array_model->setParent (subtree);
		subtree->setModel (array_model);

		//	Set subtree as widget for node.
		index = parameter_model->index (row, 1, parent);
		#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
		clog << "      subtree @ " << (void*)subtree << endl
			 << "      array_model @ " << (void*)array_model << endl
			 << "      setIndexWidget " << index << endl;
		#endif
		//	Ownership of the subtree is passed to the view.
		setIndexWidget (index, subtree);
		}
	++row;
	}
#if (DEBUG_SECTION & DEBUG_ARRAY_SUBTREES)
clog << "<<< Parameter_Tree_View::subtrees: " << (subtree != NULL) << endl;
#endif
return subtree;
}


}	// end namespace HiRISE
}	// end namespace UA
